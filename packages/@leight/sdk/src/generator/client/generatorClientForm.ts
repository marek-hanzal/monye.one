import {withSourceFile}  from "@leight/generator-server";
import {BlockStore}      from "@leight/utils-client";
import {normalize}       from "node:path";
import {type IGenerator} from "../../api";

export interface IGeneratorClientFormParams {
    forms: IGeneratorClientFormParams.IForm[];
}

export namespace IGeneratorClientFormParams {
    export interface IForm {
        /**
         * Base name exported (used to name all exported objects)
         */
        name: string;
        translation: {
            namespace: string;
        };
        packages?: IPackages;
        withTrpc?: IWithTrpc;
    }

    export interface IWithTrpc {
        source: string;
    }

    export interface IPackages {
        /**
         * Package used to import all schema-related types (ISource implementation, IWhere and so on, can be generated by @leight).
         */
        schema?: string;
    }
}

export const generatorClientForm: IGenerator<IGeneratorClientFormParams> = async (
    {
        folder,
        barrel,
        params: {forms}
    }) => {
    const file = withSourceFile();

    file.withImports({
        imports: {
            "@leight/form-client": [
                "createFormContext",
                "createMantineFormContext",
                "type IMantineFormContext",
                "Form",
                "type IFormProps",
                "type InferFormSchemas",
                "type IWithInputProps",
                "WithInput",
            ],
            "react":               [
                "type FC",
            ],
        },
    });

    forms.forEach(({name, translation, withTrpc, packages}) => {
        file
            .withImports({
                imports: {
                    [packages?.schema || `../schema`]: [
                        `${name}FormSchema`,
                    ],
                },
            })
            .withImports({
                imports: withTrpc ? {
                    ["./ClientTrpcSource"]: [
                        `Use${withTrpc.source}SourceQuery`,
                    ]
                } : {},
            })
            .withTypes({
                exports: {
                    [`I${name}FormSchema`]:         `InferFormSchemas<typeof ${name}FormSchema>`,
                    [`I${name}MantineFormContext`]: `IMantineFormContext<I${name}FormSchema>`,
                }
            })
            .withConsts({
                exports: {
                    [`${name}FormStoreContext`]:   {
                        body: `
createFormContext<I${name}FormSchema>({
    name: "${name}Form",
})
                        `,
                    },
                    [`${name}BaseForm`]:           {
                        type: `FC<I${name}BaseFormProps>`,
                        body: `
props => {
    return <Form<I${name}FormSchema>
        MantineContext={${name}MantineFormContext}
        schemas={${name}FormSchema}
        FormContext={${name}FormStoreContext}
        withTranslation={{
            namespace: "${translation.namespace}",
            label:     "${name}BaseForm",
        }}
        {...props}
    />;
}
                        `,
                    },
                    [`${name}Input`]:              {
                        type: `FC<Omit<IWithInputProps<I${name}FormSchema>, "FormContext">>`,
                        body: `
props => {
    return <WithInput
        FormContext={${name}FormStoreContext}
        {...props}
    />;
}
                            `,
                    },
                    [`${name}MantineFormContext`]: {
                        body: `createMantineFormContext<I${name}FormSchema>()`,
                    },
                },
            })
            .withInterfaces({
                exports: {
                    [`I${name}BaseFormProps`]: {
                        extends: [
                            {
                                type: `Omit<IFormProps<I${name}FormSchema>, "FormContext" | "MantineContext" | "withTranslation">`,
                            },
                        ],
                    },
                },
            });
        if (withTrpc) {
            file
                .withImports({
                    imports: {
                        "@leight/form-client":  [
                            "type ITrpcFormProps",
                        ],
                        "@leight/utils-client": [
                            "BlockStore",
                        ],
                    },
                })
                .withInterfaces({
                    exports: {
                        [`I${name}TrpcFormProps`]: {
                            extends: [
                                {
                                    type: `I${name}BaseFormProps`,
                                },
                                {
                                    type: `ITrpcFormProps<I${name}FormSchema>`,
                                },
                            ],
                        },
                    },
                })
                .withConsts({
                    exports: {
                        [`${name}TrpcForm`]: {
                            type: `FC<I${name}TrpcFormProps>`,
                            body: `
({onSuccess, onError, onSettled, ...props}) => {
    const {block} = BlockStore.useOptionalState() || {block: () => null};
    const mutation = Use${withTrpc.source}SourceQuery.useCreate();
    return <${name}BaseForm
        onSubmit={({request}) => {
            block(true);
            mutation.mutate(request, {
                onSuccess: dto => {
                    onSuccess?.({dto});
                },
                onError: error => {
                    onError?.({error});                    
                },
                onSettled: () => {
                    block(false);
                    onSettled?.({});
                },
            });
        }}
        {...props}
    />;
};
                            `,
                        }
                    },
                });

        }
    });

    file.saveTo({
        file: normalize(`${process.cwd()}/${folder}/ClientForm.tsx`),
        barrel,
    });
};
